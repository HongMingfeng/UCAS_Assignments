### NetLogo简介（第3-8页）

**NetLogo简介**

1. **历史背景**
   - **Logo语言**：最早用于乐高机器人设计的编程语言，机器人被称为“海龟”（Turtle）。
   - **StarLogo**：由Mitchel Resnick和Eric Klopfer等人将Logo语言扩展为StarLogo工具，用于儿童教学。
   - **NetLogo**：由美国西北大学的Uri Wilensky开发，专为多主体建模（Agent-Based Modeling，ABM）教学设计，特别适合复杂适应系统建模。

2. **主要功能**
   - **多主体建模**：支持多个Agent在二维空间中自主行动，所有主体并行异步更新，系统随时间动态演变。
   - **仿真控制与输出**：NetLogo提供丰富的仿真监控和结果输出功能，包括3D显示（如Flocking Demo模型）。
   - **高级应用**：
     - **BehaviorSpace**：自动管理仿真运行并记录结果。
     - **NetLogo Web**：提供在线版本，支持在线运行和分享模型。
     - **HubNet参与式仿真**：如GridLock模型中每人控制一个交通信号灯，实现多人交互仿真。

3. **NetLogo中的三类主体**
   - **turtles（海龟）**：能够在网格世界中移动，代表主动Agent，具有连续坐标。
   - **patches（瓦片）**：组成世界的矩形网格单元，具有离散整数坐标，不能移动，但可承载多个turtles。
   - **observer（观察者）**：全局主体，负责监视和控制仿真，能够获取世界的全局状态信息并执行指令。

4. **仿真过程**
   - **初始化例程（setup）**：设定初始状态，包括生成所需的turtles和设置其状态。
   - **执行例程（go）**：控制仿真执行过程，每个仿真步按例程中的指令运行，直至停止条件满足。
   - **按钮关联**：在Interface页面添加一个“go”按钮，点击后自动执行go例程，重复仿真直到用户终止或遇到stop指令。

---

**NetLogo界面**

1. **界面组成**
   - **Interface**：用于添加和操作控件。
   - **Info**：提供模型文档说明，帮助用户理解模型的背景、设计和使用方式。
   - **Code**：编写模型代码的区域，包含两类过程：
     - **命令过程（Command Process）**：以“to”开头，用于定义模型行为。
     - **报告过程（Reporter Process）**：以“to-report”开头，用于输出结果。

2. **优缺点**
   - **优点**：
     - 丰富的模型库（Ctrl+M），内置模型便于学习和模仿。
     - 操作简单，适合初学者，用于验证简单ABM的实现效果。
     - 资源丰富，网上有大量教程和示例模型供参考。
   - **缺点**：
     - NetLogo语言本身有限制，与其他编程语言和工具的互动较为困难，适用性有限。

### NetLogo编程基础与应用

**NetLogo的编程结构**

1. **基本结构**
   - **命令**：用于操作主体的行为，如`forward`（向前移动）、`right`（右转）等。
   - **过程**：将多个命令组合为一个操作模块，以`to`开头，如`to move`定义一个名为move的移动过程，结束时用`end`。
   - **变量**：可分为全局变量、局部变量和主体变量。全局变量通过`globals`定义，局部变量在过程内定义，而主体变量由`turtles`或`patches`特定持有。

2. **主体和世界**
   - **turtles（海龟）**：NetLogo中的主要活动Agent，具有如坐标、颜色、方向等属性。可使用`create-turtles`生成多个海龟并为其设置初始状态。
   - **patches（瓦片）**：组成世界的网格单元，每个patch拥有固定位置和属性（如颜色），可以携带多只turtle。
   - **observer（观察者）**：全局控制者，负责初始化世界并执行仿真例程。

**NetLogo的基本指令**

1. **移动和旋转**
   - `forward n`：让turtle向当前方向移动n个单位。
   - `right n`和`left n`：让turtle分别右转或左转n度。
   - `setxy x y`：将turtle移动到指定坐标(x, y)。
   
2. **随机化**
   - `random n`：生成一个0到n-1的随机整数。
   - `random-float n`：生成一个0到n之间的随机浮点数。
   - `one-of`：从集合中随机选择一个元素。
   
3. **条件判断与循环**
   - **条件判断**：使用`if`和`ifelse`，如`if color = red [ forward 1 ]`。
   - **循环**：使用`repeat`（重复）、`foreach`（针对集合中的每个元素）、`while`（满足条件时执行）。

4. **绘图和视觉效果**
   - **turtles的颜色与形状**：使用`set color`和`set shape`设置turtle的颜色和形状。
   - **patches的颜色**：使用`set pcolor`更改patch的颜色，生成背景或环境。
   - **更新显示**：使用`display`和`tick`控制屏幕刷新和仿真步的推进。

---

**NetLogo的建模过程**

1. **初始化（setup）**
   - **定义初始状态**：通过`clear-all`清除界面和变量，使用`create-turtles`和`set`命令生成和设置turtle的初始状态。
   - **环境设置**：设置patch的状态，如颜色、数值等，以便仿真中的主体与环境交互。

2. **仿真执行（go）**
   - **行为执行**：编写`turtles`和`patches`的行为规则，通过`ask`命令向主体下达指令。
   - **计时与控制**：每执行一个仿真步使用`tick`，在界面上展示系统变化过程。

---

**NetLogo的应用示例**

1. **扩散模型**
   - **目标**：模拟污染物或病毒在空间中的扩散过程。
   - **实现**：定义一个初始污染源，周围的patch根据扩散概率逐步被污染。
   - **代码要点**：
     - 使用patch属性存储污染状态。
     - 定义`spread`过程，将污染逐步扩散到周围patch，扩散率可随机化以增加真实性。

2. **捕食者-猎物模型（Predator-Prey Model）**
   - **目标**：模拟捕食者和猎物之间的生态动态关系。
   - **实现**：定义捕食者和猎物为两类turtles，捕食者捕猎成功率和猎物繁殖率决定生态平衡。
   - **代码要点**：
     - 捕食者消耗猎物，若能成功捕猎则生存，否则死亡。
     - 猎物以一定概率繁殖，数量影响捕食者数量变化。

3. **群体行为模型**
   - **目标**：模拟鸟群、鱼群等群体行为的集体运动模式。
   - **实现**：定义每个turtle为一个个体，它们会依据邻近个体的位置调整方向和速度。
   - **代码要点**：
     - 每个个体观察周围邻居的平均方向，以该方向移动，形成群体行为。

---

**NetLogo的控制与调试**

1. **调试技巧**
   - **监控变量**：通过监视器实时观察变量的值，便于追踪系统状态。
   - **输出日志**：使用`print`在控制台输出信息，用于检查各过程的执行情况。
   - **断点与单步执行**：可以手动执行每个过程，逐步查看模型的动态变化。

2. **性能优化**
   - **减少turtles数量**：复杂模型中减少turtles数量以提升性能。
   - **降低刷新频率**：使用`no-display`关闭自动刷新，待计算完成后手动更新显示。

### 复杂科学（第10-15页）

**复杂科学的历史背景**

1. **老三论**  
   - **系统论**（Systems Theory）：由贝塔朗菲（1932-1968）提出，强调整体与部分的关系，是复杂科学的早期理论基础。
   - **控制论**（Cybernetics Theory）：由维纳（1948）提出，研究通信与控制的机制，主要应用于生物系统和自动控制系统。
   - **信息论**（Information Theory）：由香农（1948）提出，研究信息传递的效率和可靠性，广泛应用于通信、计算机科学等领域。

2. **新三论**  
   - **耗散结构论**（Dissipative Structure Theory）：普里戈金（1969）提出，研究系统远离平衡态时的自组织行为，解释了如何通过开放系统的物质与能量交换实现有序。
   - **协同学**（Synergetics）：哈肯（1971-1976）提出，探讨如何在多种要素协同作用下产生整体行为，适用于物理、化学、生物和社会系统。
   - **突变论**（Catastrophic Change Theory）：由雷内·托姆（1972）提出，分析系统在不同状态之间的突然转变，如灾害和剧变现象。

---

**非线性科学**

1. **混沌动力学理论**（Chaos Theory）  
   - 研究确定性系统中不确定行为的现象。爱德华·洛伦兹（1963）提出的混沌理论表明系统对初始条件的高度敏感性，即所谓的“蝴蝶效应”。
   - 洛伦兹简化了天气系统的对流模型，揭示了气象系统中的不确定性，为研究非线性现象提供了基础。

2. **分形理论**（Fractals）  
   - 曼德尔布洛特（1977）提出，研究自然界的自相似结构。分形理论应用于复杂图形的生成和自然现象的模拟，通过分数维数表示物体的几何特性。
   - 例如，科赫曲线具有无穷长而有限面积，展示了分形几何学的特点。

3. **孤波理论**（Solitons）  
   - 研究非线性波动现象，由罗素（1834）首先观察到，后由费米（1965）等人进一步研究。孤波理论解释了从不稳定到稳定的波动过程，适用于研究水波、等离子体等自然现象。
   - 孤波现象不仅存在于水中，还可以出现在声音、电磁和光波中。

---

**洛伦兹的蝴蝶效应**

- **核心思想**：小的初始条件变化可能会导致大规模的系统变化，即“蝴蝶效应”。这说明了非线性系统对初始状态的高度敏感性。
- **重要性**：洛伦兹的发现促使科学家重新审视自然系统的可预测性问题，探索系统中不确定性与确定性的关系。这种现象对天气预报和气候模型的研究具有重大影响。

### 元胞自动机（第16-29页）

**元胞自动机的基本概念**

1. **定义与特点**  
   - **元胞自动机**（Cellular Automata，CA）是一种离散的计算模型，由许多格点组成网格空间，每个格点（元胞）根据特定规则和其邻居的状态进行更新。
   - **时间和空间离散**：在一个离散化的网格（lattice grid）中，元胞的状态随着离散的时间步进变化。CA模型特别适用于材料科学等领域，用于模拟材料的生长和晶体结构。

2. **发展历程**
   - **初等元胞自动机**（Elementary Cellular Automata）：由沃尔夫勒姆（Wolfram）于1986年提出，使用二进制状态（0或1）和简单的邻居关系（半径为1）来定义规则。
   - **生命游戏**（Game of Life）：由康威（Conway）于1970年发明，用围棋盘模拟生物体的繁衍与竞争。经典规则包括：
     - 若一个元胞有两个或三个邻居为“生”，则继续“生”存，否则死亡。
     - 若一个元胞有三个邻居为“生”，则复活。

3. **元胞自动机的应用**
   - **生命游戏的通用性**：康威的“生命游戏”模型具有图灵完备性，即可以模拟任何计算机的运算过程。
   - **图案示例**：常见的生命游戏图案包括“滑翔机”（Glider）和“播种机”（Seeder），通过简单的规则可以产生复杂的、有序的系统行为。
   - **大规模系统模拟**：生命游戏模型展示了通过简单规则产生复杂涌现行为的能力，为人工生命和复杂系统建模提供了理论基础。

4. **应用实例**
   - **材料科学**：用于研究晶体的生长、材料的断裂与扩散等。
   - **计算机科学**：CA模型可以用于图形生成、数据加密以及自复制机器的理论研究。
   - **生命科学**：模拟生物系统的动态变化，如群体行为与生态系统中的种群扩展。

### 复杂系统框架（第31-32页）

**复杂科学与系统科学、非线性科学的对比**

1. **相同点**
   - 研究对象都是复杂系统，关注系统的结构与行为规律。

2. **不同点**
   - **系统科学**：将复杂系统、经典力学系统、热力学系统等视为开放系统，注重系统整体的协调性和稳定性。
   - **非线性科学**：将复杂系统视为受非线性作用影响而产生不确定性行为的系统，强调系统中的非线性和反馈机制，研究系统在不同初始条件下的多样化演化路径。

---

**复杂系统理论框架**

1. **老三论**  
   - **系统论**（Systems Theory）：研究系统的整体性，强调系统内各部分之间的关系。
   - **控制论**（Cybernetics Theory）：研究信息传递与反馈控制。
   - **信息论**（Information Theory）：研究信息的传递效率与可靠性。

2. **新三论**  
   - **耗散结构论**（Dissipative Structure Theory）：研究系统在远离平衡态时的自组织行为。
   - **协同学**（Synergetics）：研究多要素协同作用下的整体行为。
   - **突变论**（Catastrophic Change Theory）：研究系统状态之间的突然转变。

3. **非线性科学**  
   - **混沌动力学理论**（Chaos Theory）：研究确定性系统中的不确定性行为。
   - **分形理论**（Fractals）：研究自相似的几何结构。
   - **孤波理论**（Solitons）：研究非线性波动的稳定传播现象。

### 复杂系统核心概念（第31-40页）

**复杂系统的核心概念**

1. **复杂系统的定义**
   - **中等数目**：包含适量主体，数量适中。
   - **局部感知**：系统由多个具有局部感知能力的个体构成，且无中央控制。
   - **自适应性**：个体根据环境反馈调整自身行为。
   - **非线性**：系统行为并非线性叠加，往往具有复杂反馈机制。
   - **涌现性**：微观层面的行为难以直接预测宏观表现，反之亦然。

2. **涌现现象**  
   - **定义**：整体层面的行为或模式，无法从个体层面简单推导出来。涌现现象通常表现为系统自发形成的有序结构。
   - **案例**：复杂系统中的涌现现象包括生态系统的平衡、人类社会中的分工协作等。

3. **复杂系统的调控**
   - **大系统控制**  
      - **特点**：状态多、维度高、内部关联复杂、信息不完全且目标多样化。
      - **控制方式**：
         - **结构分析**：分析系统的动态因果关系和结构特征。
         - **信息集结**：通过信息压缩降低系统的维度。
         - **递阶分层**：将系统垂直分解为多层次结构。
         - **分解-协调**：将高维问题分解为低维子问题，并通过协调不断优化。
         - **分散化/分布式**：由多个控制器分别控制系统的局部部分。

   - **软控制**  
      - **定义**：通过加入特殊主体（shills）来引导系统的集体行为，无需改变既有规则。
      - **应用**：在多主体系统中，通过引入“聪明”的引导者可在不改变系统规则的情况下实现集体行为的控制。

### 复杂适应系统理论（第42-52页）

**复杂适应系统理论（CAS）的核心思想**

- **复杂适应系统**（Complex Adaptive System, CAS）：由多个微观主体通过相互作用和自适应行为形成的系统。这些主体根据经验积累，不断调整其规则以适应环境，最终在宏观层面呈现出复杂性和涌现现象。

---

**CAS的七个基本概念**

1. **四个特性**
   - **聚集（Aggregation）**  
      - 主体按相似性聚合形成更高层级的“中介主体”。
   - **非线性（Non-linearity）**  
      - 系统中的反馈机制复杂交织，非单向和非被动，使得小变化可能引发大影响。
   - **流（Flow）**  
      - 系统中物质、能量和信息的流动，流的通畅性影响系统的演化。
   - **多样性（Diversity）**  
      - 主体在适应过程中会分化并占据不同生态位，导致个体间差异性增加。

2. **三个机制**
   - **标识（Tag）**  
      - 主体间通过标识（如标签）区分和识别彼此，便于选择合作或竞争对象。
   - **内部模型（Internal Model）**  
      - 主体依据“如果-那么”的规则构建自身对外部环境的认知模型。
   - **积木块（Building Blocks）**  
      - 现有规则可像积木块一样重组，生成新的规则来适应环境变化。

---

**CAS理论的特点**

1. **主体的主动性**：CAS中的主体能够主动选择和适应，不只是被动响应外部环境，适用于社会、经济、生态等多种系统。
2. **宏观与微观的联系**：通过自下而上的方式，将微观主体的行为与宏观现象联系起来，突破了还原论的限制。
3. **随机性与优化机制**：系统演化中引入随机因素和优化机制（如遗传算法）来模拟主体的适应过程。

---

**CAS理论的方法论与贡献**

1. **建模方法**：采用基于主体的建模与仿真方法（Agent-Based Modeling and Simulation, ABMS），通过刻画主体的行为与交互关系来理解系统涌现现象。
2. **实际应用**：CAS理论通过ABM构建复杂系统的模型，提供了一种从微观出发理解系统整体行为的方法。

3. **CAS理论的局限性**
   - 主要受生物学痕迹影响较大，在其他学科的应用上仍需进一步探索与研究。

---

**CAS理论与ABMS方法的实际应用**

1. **经济领域**：应用于**基于主体的计算经济学**（Agent-Based Computational Economics, ACE），例如美国Sandia国家实验室的Aspen模型，用于仿真美国经济。
2. **金融领域**：应用于**基于主体的计算金融学**，如SFI开发的人工股票市场，用于研究NASDAQ市场的行为。
3. **交通领域**：通过TRANSIMS系统对交通行为进行仿真，已形成成熟的应用。
4. **军事领域**：应用于战争模拟和核打击仿真等军事对抗模拟。

---

**CAS理论的其他应用领域**

- **生态环境**：研究物种相互关系、种群动态等。
- **传染病传播**：模拟疫情的传播路径与控制策略。
- **社会科学**：研究社会行为、群体动态、舆情传播等。
- **管理科学**：用于组织行为与战略决策分析。
- **游戏开发**：用于游戏中的人工智能与群体行为模拟。

### VISA2协议简介（第54-60页）

**研究背景**

1. **主体行为描述的挑战**
   - 当前的主体模型存在标准化、量化和可编程化的不足，导致仿真结果难以复现、科学性低。
   - **ODD协议**（Overview, Design concepts, Details）：用于描述主体模型，包括背景、设计概念和细节三个部分。其中设计概念涉及适应性、目标、预测、感知、交互、随机性等要素。
   - ODD协议扩展：
     - **ODD+D协议**：增加了反映人类决策行为的三个概念，拓展了在管理科学领域的应用。

2. **国内研究现状**
   - 国内尚无扩展或替代ODD协议的标准化主体模型研究，标准化研究依然较为薄弱。

---

**VISA2协议**

1. **研究方案**
   - 初步确定了VISA2协议的八大要素，分为两个层级。
   - 将数学工具引入主体模型描述，如用矩阵表示主体交互关系，用函数表达内部模型。
   - 融合面向对象编程（OOP）特性和关键要素，将主体类型视作类与对象，主体属性视作类的变量，主体交互则封装在类的方法中。

2. **Agent-Level VISA**
   - **Agent**：定义主体的类型、关系、拓扑结构。
   - **Variable**：描述主体的属性和变量。
   - **Sensing**：描述主体间的信息交互。
   - **Internal Model**：描述主体的内部行为，改变属性和变量的数值。

3. **Model-Level VISA**
   - **Schedule**：定义模型的时序。
   - **Input & Output**：定义模型的输入和输出。
   - **Associated Data**：定义模型相关数据。
   - **Validation**：模型的验证方法。

---

**VISA2协议的数学语言表达**

1. **Agent-Level VISA**
   - **Agent**：将主体视为集合。
   - **Variable**：用数学符号表示主体变量。
   - **Sensing**：使用矩阵与集合表示主体间信息的传递。
   - **Internal Model**：通过公式描述主体内部模型。

2. **Model-Level VISA**
   - **Schedule**：定义时序中的随机变量分布。
   - **Input & Output**：计算指标的公式。
   - **Associated Data**：以元数据表格的形式记录。
   - **Validation**：使用统计检验方法进行模型验证。

---

**VISA2协议的计算机语言表达**

1. **Agent-Level VISA**
   - **Agent**：以类图方式表示主体类型。
   - **Variable**：通过类的属性定义变量。
   - **Sensing**：控制属性的访问域以实现信息交互。
   - **Internal Model**：将内部模型定义为类的函数。

2. **Model-Level VISA**
   - **Schedule**：用伪代码描述模型的时序。
   - **Input & Output**：通过实验设计记录输入输出关系。
   - **Associated Data**：将相关数据存入数据库。
   - **Validation**：使用有监督学习方法进行模型验证。